***************
*** 45,56 ****
  #include "video.hpp"
  
  #include <algorithm>
  
  static lg::log_domain log_engine("engine");
  #define LOG_SAVE LOG_STREAM(info, log_engine)
  #define ERR_SAVE LOG_STREAM(err, log_engine)
  
  static lg::log_domain log_enginerefac("enginerefac");
  #define LOG_RG LOG_STREAM(info, log_enginerefac)
  
  
--- 50,64 ----
  #include "video.hpp"
  
  #include <algorithm>
+ #include <iomanip>
+ #include <sstream>
  
  static lg::log_domain log_engine("engine");
  #define LOG_SAVE LOG_STREAM(info, log_engine)
  #define ERR_SAVE LOG_STREAM(err, log_engine)
  
  static lg::log_domain log_enginerefac("enginerefac");
+ #define DBG_RG LOG_STREAM(debug, log_enginerefac)
  #define LOG_RG LOG_STREAM(info, log_enginerefac)
  
  
***************
*** 634,702 ****
  	out.close_child("replay");
  }
  
- //changes done during 1.11.0-dev
- static void convert_old_saves_1_11_0(config& cfg)
  {
- 	if(!cfg.has_child("snapshot")){
- 		return;
  	}
  
- 	const config& snapshot = cfg.child("snapshot");
- 	const config& replay_start = cfg.child("replay_start");
- 	const config& replay = cfg.child("replay");
  
  	if(!cfg.has_child("carryover_sides") && !cfg.has_child("carryover_sides_start")){
  		config carryover;
  		//copy rng and menu items from toplevel to new carryover_sides
  		carryover["random_seed"] = cfg["random_seed"];
  		carryover["random_calls"] = cfg["random_calls"];
- 		for(const config& menu_item : cfg.child_range("menu_item")) {
  			carryover.add_child("menu_item", menu_item);
  		}
  		carryover["difficulty"] = cfg["difficulty"];
- 		carryover["random_mode"] = cfg["random_mode"];
  		//the scenario to be played is always stored as next_scenario in carryover_sides_start
  		carryover["next_scenario"] = cfg["scenario"];
  
  		config carryover_start = carryover;
  
- 		//copy sides from either snapshot or replay_start to new carryover_sides
- 		if(!snapshot.empty()){
- 			for(const config& side : snapshot.child_range("side")) {
- 				carryover.add_child("side", side);
- 			}
- 			//for compatibility with old savegames that use player instead of side
- 			for(const config& side : snapshot.child_range("player")) {
- 				carryover.add_child("side", side);
- 			}
- 			//save the sides from replay_start in carryover_sides_start
- 			for(const config& side : replay_start.child_range("side")) {
- 				carryover_start.add_child("side", side);
- 			}
- 			//for compatibility with old savegames that use player instead of side
- 			for(const config& side : replay_start.child_range("player")) {
- 				carryover_start.add_child("side", side);
- 			}
- 		} else if (!replay_start.empty()){
- 			for(const config& side : replay_start.child_range("side")) {
- 				carryover.add_child("side", side);
- 				carryover_start.add_child("side", side);
- 			}
- 			//for compatibility with old savegames that use player instead of side
- 			for(const config& side : replay_start.child_range("player")) {
- 				carryover.add_child("side", side);
- 				carryover_start.add_child("side", side);
- 			}
- 		}
- 
  		//get variables according to old hierarchy and copy them to new carryover_sides
  		if(!snapshot.empty()){
- 			if(const config& variables_from_snapshot = snapshot.child("variables")){
- 				carryover.add_child("variables", variables_from_snapshot);
  				carryover_start.add_child("variables", replay_start.child_or_empty("variables"));
- 			} else if (const config& variables_from_cfg = cfg.child("variables")){
- 				carryover.add_child("variables", variables_from_cfg);
- 				carryover_start.add_child("variables", variables_from_cfg);
  			}
  		} else if (!replay_start.empty()){
  			if(const config& variables = replay_start.child("variables")){
--- 642,1824 ----
  	out.close_child("replay");
  }
  
+ std::string convert_version_to_suffix(config& cfg)
  {
+ 	std::string suffix = "";
+ 	version_info loaded_version(cfg["version"]);
+ 
+ 	if(loaded_version < version_info("1.5.0") && loaded_version >= version_info("1.3.0"))
+ 		suffix = "_1_4";
+ 	if(loaded_version < version_info("1.7.0") && loaded_version >= version_info("1.5.0"))
+ 		suffix = "_1_6";
+ 	if(loaded_version < version_info("1.9.0") && loaded_version >= version_info("1.7.0"))
+ 		suffix = "_1_8";
+ 	if(loaded_version < version_info("1.11.0") && loaded_version >= version_info("1.9.0"))
+ 		suffix = "_1_10";
+ 	if(loaded_version < version_info("1.13.0") && loaded_version >= version_info("1.11.0"))
+ 		suffix = "_1_12";
+ 
+ 	return suffix;
+ }
+ 
+ std::string append_suffix_to_unit_type(std::string unit_type, config& cfg)
+ {
+ 	const std::string suffix = convert_version_to_suffix(cfg);
+ 	return unit_type + suffix;
+ }
+ 
+ void update_start_unit_types(config& replay_start, config& cfg)
+ {
+ 	const std::string suffix = convert_version_to_suffix(cfg);
+ 	if(not suffix.empty())
+ 	{
+ 		for(config& side : replay_start.child_range("side"))
+ 		{
+  			std::ostringstream ss, tt, uu;
+  			// BFW 1.4, 1.6
+  			std::string sep = "";
+ 			for(const std::string& leader : utils::split(side["leader"], ','))
+ 			{
+ 				ss << sep << leader << suffix;
+ 				sep = ",";
+ 			}
+ 			std::string new_leader = ss.str();
+ 			side["leader"] = new_leader;
+  			if (side.has_attribute("recruit"))
+ 			{
+  				sep = "";
+ 				for(const std::string& recruit : utils::split(side["recruit"], ','))
+ 				{
+ 					uu << sep << recruit << suffix;
+ 					sep = ",";
+ 				}
+ 				std::string new_recruit = uu.str();
+ 				side["recruit"] = new_recruit;
+ 			}
+  			if (side.has_attribute("random_leader"))
+ 			{
+  				sep = "";
+ 				for(const std::string& leader : utils::split(side["random_leader"], ','))
+ 				{
+ 					tt << sep << leader << suffix;
+ 					sep = ",";
+ 				}
+ 				std::string new_random = tt.str();
+ 				side["random_leader"] = new_random;
+ 			}
+  			if (side.has_attribute("type")) side["type"] = side["type"].str()+suffix;
+ 
+  			// BFW 1.8
+  			if (side.has_attribute("previous_recruits"))
+ 			{
+  				sep = "";
+ 				for(const std::string& recruit : utils::split(side["previous_recruits"], ','))
+ 				{
+ 					uu << sep << recruit << suffix;
+ 					sep = ",";
+ 				}
+ 			std::string new_recruit = uu.str();
+ 			side["previous_recruits"] = new_recruit;
+ 			}
+ 			for(config& unit : side.child_range("unit"))
+ 			{
+ 				bool found = unit["type"].str().find(suffix, 0);
+ 				if(found == std::string::npos)
+ 				{
+ 					unit["type"] = unit["type"].str()+suffix;
+  					std::ostringstream vv;
+  					sep = "";
+ 					for(const std::string& leader : utils::split(unit["advances_to"], ','))
+ 					{
+ 						vv << sep << leader << suffix;
+ 						sep = ",";
+ 					}
+ 					std::string new_advance = vv.str();
+ 					unit["advances_to"] = new_advance;
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void update_replay_unit_types(config& replay, config& cfg)
+ {
+ 	const std::string suffix = convert_version_to_suffix(cfg);
+ 	if(suffix.empty()) return;
+ 	for(config& command : replay.child_range("command"))
+ 	{
+  		// BFW 1.12
+  		if (config& recruit = command.child("recruit"))
+ 		{
+  			recruit["type"] = recruit["type"] + suffix;
+ 		}
+ 		if (config& attack = command.child("attack"))
+ 		{
+ 			if (attack.has_attribute("attacker_type"))
+ 			{
+ 				attack["attacker_type"] = attack["attacker_type"] + suffix;
+ 				attack["defender_type"] = attack["defender_type"] + suffix;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void feral_trait_1_8_enter_hex(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "		name=enter_hex\n";
+ 	ss << "		first_time_only=no\n";
+ 	ss << "		[filter]\n";
+ 	ss << "			race=bats_1_8\n";
+ 	ss << "			[filter_location]\n";
+ 	ss << "				terrain=Ss^Vhs,Uu^Vu*,Dd^Vd*,Hh^Vhh*,Hhd^Vhh*,Aa^V*\n";
+ 	ss << "			[/filter_location]\n";
+ 	ss << "		[/filter]\n";
+ 	ss << "     [command]\n";
+ 	ss << "         [object]\n";
+ 	ss << "             id=compatible_1_8_feral\n";
+ 	ss << "             take_only_once=no\n";
+ 	ss << "             duration=forever\n";
+ 	ss << "             silent=yes\n";
+ 	ss << "             description=\"In BFW 1.8, feral don't apply to this village.\"\n";
+ 	ss << "             [filter]\n";
+ 	ss << "                 id=$unit.id\n";
+ 	ss << "             [/filter]\n";
+ 	ss << "             [effect]\n";
+ 	ss << "                 apply_to=defense\n";
+ 	ss << "                 replace=yes\n";
+ 	ss << "                 [defense]\n";
+ 	ss << "                     village=40\n";
+ 	ss << "                 [/defense]\n";
+ 	ss << "             [/effect]\n";
+ 	ss << "		    [/object]\n";
+ 	ss << "         [on_undo]\n";
+ 	ss << "             [remove_object]\n";
+ 	ss << "                 object_id=compatible_1_8_feral\n";
+ 	ss << "                 id=$unit.id\n";
+ 	ss << "             [/remove_object]\n";
+ 	ss << "         [/on_undo]\n";
+ 	ss << "         [allow_undo]\n";
+ 	ss << "         [/allow_undo]\n";
+ 	ss << "     [/command]\n";
+ 	read(event, ss);
+ }
+ 
+ void feral_trait_1_8_exit_hex(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "		name=exit_hex\n";
+ 	ss << "		first_time_only=no\n";
+ 	ss << "		[filter]\n";
+ 	ss << "			race=bats_1_8\n";
+ 	ss << "			[filter_location]\n";
+ 	ss << "				terrain=Ss^Vhs,Uu^Vu*,Dd^Vd*,Hh^Vhh*,Hhd^Vhh*,Aa^V*\n";
+ 	ss << "			[/filter_location]\n";
+ 	ss << "		[/filter]\n";
+ 	ss << "     [command]\n";
+ 	ss << "         [remove_object]\n";
+ 	ss << "             object_id=compatible_1_8_feral\n";
+ 	ss << "             id=$unit.id\n";
+ 	ss << "         [/remove_object]\n";
+ 	ss << "     [/command]\n";
+ 	read(event, ss);
+ }
+ 
+ void rounding_trait_1_8_add_one_hitpoint(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        name=\"add one hitpoint at recruit\"\n";
+ 	ss << "        first_time_only=no\n";
+ 	ss << "        [command]\n";
+ 	ss << "            [object]\n";
+ 	ss << "                duration = forever\n";
+ 	ss << "                id=\"compatible_1_8_rounding_trait\"\n";
+ 	ss << "                silent=yes\n";
+ 	ss << "                take_only_once=no\n";
+ 	ss << "                [filter]\n";
+ 	ss << "                    x,y=$x1,$y1\n";
+ 	ss << "                [/filter]\n";
+ 	ss << "                [effect]\n";
+ 	ss << "                    apply_to=\"hitpoints\"\n";
+ 	ss << "                    increase_total=1\n";
+ 	ss << "                    heal_full=yes\n";
+ 	ss << "                [/effect]\n";
+ 	ss << "            [/object]\n";
+ 	ss << "        [/command]\n";
+ 	read(event, ss);
+ }
+ 
+ void make_quick_leader_1_6_prestart(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        name=\"prestart\"\n";
+ 	ss << "        [store_unit]\n";
+ 	ss << "            kill=yes\n";
+ 	ss << "            variable=\"leaders_to_make_quick\"\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                canrecruit=yes\n";
+ 	ss << "                [filter_wml]\n";
+ 	ss << "                    max_moves=4\n";
+ 	ss << "                [/filter_wml]\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "        [/store_unit]\n";
+ 	ss << "        [set_variable]\n";
+ 	ss << "            name=\"i\"\n";
+ 	ss << "            value=0\n";
+ 	ss << "        [/set_variable]\n";
+ 	ss << "        [while]\n";
+ 	ss << "            [variable]\n";
+ 	ss << "                less_than=\"$leaders_to_make_quick.length\"\n";
+ 	ss << "                name=\"i\"\n";
+ 	ss << "            [/variable]\n";
+ 	ss << "            [do]\n";
+ 	ss << "                [if]\n";
+ 	ss << "                    [variable]\n";
+ 	ss << "                        boolean_equals=yes\n";
+ 	ss << "                        name=\"leaders_to_make_quick[$i].variables.dont_make_me_quick\"\n";
+ 	ss << "                    [/variable]\n";
+ 	ss << "                    [then]\n";
+ 	ss << "                        [unstore_unit]\n";
+ 	ss << "                            variable=\"leaders_to_make_quick[$i]\"\n";
+ 	ss << "                        [/unstore_unit]\n";
+ 	ss << "                    [/then]\n";
+ 	ss << "                    [else]\n";
+ 	ss << "                        [set_variables]\n";
+ 	ss << "                            name=\"temp\"\n";
+ 	ss << "                            [literal]\n";
+ 	ss << "                                [trait]\n";
+ 	ss << "#textdomain wesnoth-help\n";
+ 	ss << "                                    female_name=_\"female^quick\"\n";
+ 	ss << "                                    id=\"quick\"\n";
+ 	ss << "                                    male_name=_\"quick\"\n";
+ 	ss << "                                    [effect]\n";
+ 	ss << "                                        apply_to=\"movement\"\n";
+ 	ss << "                                        increase=1\n";
+ 	ss << "                                    [/effect]\n";
+ 	ss << "                                    [effect]\n";
+ 	ss << "                                        apply_to=\"hitpoints\"\n";
+ 	ss << "                                        increase_total=\"-5%\"\n";
+ 	ss << "                                    [/effect]\n";
+ 	ss << "                                [/trait]\n";
+ 	ss << "                            [/literal]\n";
+ 	ss << "                        [/set_variables]\n";
+ 	ss << "                        [set_variables]\n";
+ 	ss << "                            mode=\"append\"\n";
+ 	ss << "                            name=\"leaders_to_make_quick[$i].modifications.trait\"\n";
+ 	ss << "                            [insert_tag]\n";
+ 	ss << "                                name=\"literal\"\n";
+ 	ss << "                                variable=\"temp.trait\"\n";
+ 	ss << "                            [/insert_tag]\n";
+ 	ss << "                        [/set_variables]\n";
+ 	ss << "                        [clear_variable]\n";
+ 	ss << "                            name=\"leaders_to_make_quick[$i].max_moves,leaders_to_make_quick[$i].moves,leaders_to_make_quick[$i].max_hitpoints,leaders_to_make_quick[$i].hitpoints\"\n";
+ 	ss << "                        [/clear_variable]\n";
+ 	ss << "                        [unstore_unit]\n";
+ 	ss << "                            variable=\"leaders_to_make_quick[$i]\"\n";
+ 	ss << "                        [/unstore_unit]\n";
+ 	ss << "                    [/else]\n";
+ 	ss << "                [/if]\n";
+ 	ss << "                [set_variable]\n";
+ 	ss << "                    add=1\n";
+ 	ss << "                    name=\"i\"\n";
+ 	ss << "                [/set_variable]\n";
+ 	ss << "            [/do]\n";
+ 	ss << "        [/while]\n";
+ 	ss << "        [clear_variable]\n";
+ 	ss << "            name=\"i\"\n";
+ 	ss << "        [/clear_variable]\n";
+ 	ss << "        [clear_variable]\n";
+ 	ss << "            name=\"leaders_to_make_quick,temp\"\n";
+ 	ss << "        [/clear_variable]\n";
+ 	read(event, ss);
+ }
+ 
+ void healthy_trait_1_6_side_turn(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        id=\"healthy side turn\"\n";
+ 	ss << "        name=\"side turn\"\n";
+ 	ss << "        first_time_only=no\n";
+ 	ss << "        [heal_unit]\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                side=$side_number\n";
+ 	ss << "                [filter_wml]\n";
+ 	ss << "                    [not]\n";
+ 	ss << "                        [status]\n";
+ 	ss << "                            poisoned=yes\n";
+ 	ss << "                        [/status]\n";
+ 	ss << "                    [/not]\n";
+ 	ss << "                    [not]\n";
+ 	ss << "                        [status]\n";
+ 	ss << "                            fighting=yes\n";
+ 	ss << "                        [/status]\n";
+ 	ss << "                    [/not]\n";
+ 	ss << "                    [modifications]\n";
+ 	ss << "                        [trait]\n";
+ 	ss << "                            id=healthy_1_6\n";
+ 	ss << "                        [/trait]\n";
+ 	ss << "                    [/modifications]\n";
+ 	ss << "                [/filter_wml]\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "            amount=2\n";
+ 	ss << "            animate=yes\n";
+ 	ss << "            restore_statuses=no\n";
+ 	ss << "        [/heal_unit]\n";
+ 	read(event, ss);
+ }
+ 
+ void healthy_trait_1_6_poisoned(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        id=\"poisoned healthy side turn\"\n";
+ 	ss << "        name=\"side turn\"\n";
+ 	ss << "        first_time_only=no\n";
+ 	ss << "        [heal_unit]\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                side=$side_number\n";
+ 	ss << "                [filter_wml]\n";
+ 	ss << "                    [status]\n";
+ 	ss << "                        poisoned=yes\n";
+ 	ss << "                    [/status]\n";
+ 	ss << "                    [modifications]\n";
+ 	ss << "                        [trait]\n";
+ 	ss << "                            id=healthy_1_6\n";
+ 	ss << "                        [/trait]\n";
+ 	ss << "                    [/modifications]\n";
+ 	ss << "                [/filter_wml]\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "            amount=2\n";
+ 	ss << "            animate=yes\n";
+ 	ss << "            restore_statuses=no\n";
+ 	ss << "        [/heal_unit]\n";
+ 	read(event, ss);
+ }
+ 
+ void healthy_trait_1_4_side_turn(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        id=\"healthy side turn\"\n";
+ 	ss << "        name=\"side turn\"\n";
+ 	ss << "        first_time_only=no\n";
+ 	ss << "        [heal_unit]\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                side=$side_number\n";
+ 	ss << "                [filter_wml]\n";
+ 	ss << "                    [not]\n";
+ 	ss << "                        [status]\n";
+ 	ss << "                            poisoned=yes\n";
+ 	ss << "                        [/status]\n";
+ 	ss << "                    [/not]\n";
+ 	ss << "                    [not]\n";
+ 	ss << "                        [status]\n";
+ 	ss << "                            fighting=yes\n";
+ 	ss << "                        [/status]\n";
+ 	ss << "                    [/not]\n";
+ 	ss << "                    [modifications]\n";
+ 	ss << "                        [trait]\n";
+ 	ss << "                            id=healthy_1_4\n";
+ 	ss << "                        [/trait]\n";
+ 	ss << "                    [/modifications]\n";
+ 	ss << "                [/filter_wml]\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "            amount=2\n";
+ 	ss << "            animate=yes\n";
+ 	ss << "            restore_statuses=no\n";
+ 	ss << "        [/heal_unit]\n";
+ 	read(event, ss);
+ }
+ 
+ void healthy_trait_1_4_turn_refresh(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        name=\"healthy turn refresh\"\n";
+ 	ss << "        name=\"turn refresh\"\n";
+ 	ss << "        first_time_only=no\n";
+ 	ss << "        [modify_unit]\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                side=$side_number\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "            [object]\n";
+ 	ss << "            [effect]\n";
+ 	ss << "                apply_to=status\n";
+ 	ss << "                remove=fighting\n";
+ 	ss << "            [/effect]\n";
+ 	ss << "            [/object]\n";
+ 	ss << "        [/modify_unit]\n";
+ 	read(event, ss);
+ }
+ 
+ void healthy_trait_1_4_attack_end(config& event)
+ {
+ 	std::stringstream ss;
+ 	ss << "        name=\"healthy attack end\"\n";
+ 	ss << "        name=\"attack end\"\n";
+ 	ss << "        first_time_only=no\n";
+ 	ss << "        [modify_unit]\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                id=$unit.id\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "            [object]\n";
+ 	ss << "                [effect]\n";
+ 	ss << "                    apply_to=status\n";
+ 	ss << "                    add=fighting\n";
+ 	ss << "                [/effect]\n";
+ 	ss << "            [/object]\n";
+ 	ss << "        [/modify_unit]\n";
+ 	ss << "        [modify_unit]\n";
+ 	ss << "            [filter]\n";
+ 	ss << "                id=$second_unit.id\n";
+ 	ss << "            [/filter]\n";
+ 	ss << "            [object]\n";
+ 	ss << "                [effect]\n";
+ 	ss << "                    apply_to=status\n";
+ 	ss << "                    add=fighting\n";
+ 	ss << "                [/effect]\n";
+ 	ss << "            [/object]\n";
+ 	ss << "        [/modify_unit]\n";
+ 	read(event, ss);
+ }
+ 
+ void update_prestart_detect_factions(config& cfg)
+ {
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& event: replay.child_range("event"))
+ 		{
+ 			if(event["name"] == "prestart")
+ 			{
+ 				if(config& fire_event = event.child("fire_event"))
+ 				{
+ 					if(fire_event["name"] == "place_units")
+ 					{
+ 						config& lua = event.child("lua");
+ 
+ 						std::string changes[] = {"if searched == actual then;if actual:sub(1, #searched) == searched  then",
+ 												"if searched == actual.type then;if actual.type:sub(1, #searched) == searched then"};
+ 						std::ostringstream ss;
+ 				 		for (std::string& line : utils::split(lua["code"].str(), '\n'))
+ 				 		{
+ 							std::size_t found;
+ 							std::string oldcode, newcode;
+ 							for(auto it=std::begin(changes); it!=std::end(changes); ++it)
+ 							{
+ 								int sep = (*it).find(";");
+ 								oldcode = (*it).substr(0, sep);
+ 								newcode = (*it).substr(sep+1);
+ 								found = line.find(oldcode, 0);
+ 								if(found != std::string::npos)
+ 								{
+ 									line.replace(found, oldcode.length(), newcode);
+ 									break;
+ 								}
+ 							}
+ 							ss << line << "\n";
+ 						}
+ 						lua["code"] = ss.str();
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void update_pre_recruited_loyals(config& cfg)
+ {
+ 	const std::string suffix = convert_version_to_suffix(cfg);
+ 	if(suffix.empty()) return;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& event: replay.child_range("event"))
+ 		{
+ 			if(event["name"] == "place_units")
+ 			{
+ 				for(config& switch_: event.child_range("switch"))
+ 				{
+ 					for(config& case_: switch_.child_range("case"))
+ 					{
+ 						for(config& unit: case_.child_range("unit"))
+ 						{
+ 							unit["type"] = unit["type"] + suffix;
+ 						}
+ 					}
+ 					if(config& else_ = switch_.child("else"))
+ 					{
+ 						for(config& unit: else_.child_range("unit"))
+ 						{
+ 							unit["type"] = unit["type"] + suffix;
+ 						}
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void convert_old_saves_1_03_0_for_BFW1_10(config& cfg)
+ {
+     config& snapshot = cfg.child("snapshot");
+     config& replay_start = cfg.child("replay_start");
+     config& replay = cfg.child("replay");
+ 
+ 	cfg.clear_children("player");
+ 	replay_start.clear_children("player");
+ 
+     // Petrify units on Caves of the Basilisk, Sulla’s Ruins, ...
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		config& era = replay.child("era");
+ 		config& side_turn_event = era.add_child("event");
+         healthy_trait_1_4_side_turn(side_turn_event);
+ 		config& turn_refresh_event = era.add_child("event");
+ 		healthy_trait_1_4_turn_refresh(turn_refresh_event);
+ 		config& attack_end_event = era.add_child("event");
+ 		healthy_trait_1_4_attack_end(attack_end_event);
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			for(config& unit: side.child_range("unit"))
+ 			{
+ 				if(config& status = unit.child("status"))
+ 				{
+ 					if(status.has_attribute("stone"))
+ 					{
+ 						status.remove_attribute("stone");
+ 						status["stoned"]="on";
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+     if(config& replay = cfg.child("replay"))
+     {
+         for(config& command: replay.child_range("command"))
+         {
+             if(config& speak = command.child("speak"))
+             {
+                 speak["id"] = speak["description"];
+                 speak.remove_attribute("description");
+             }
+             if(config& move = command.child("move"))
+             {
+                 config& source = move.child("source");
+                 config& destination = move.child("destination");
+                 std::stringstream xx, yy;
+                 xx << source["x"] << "," << destination["x"];
+                 yy << source["y"] << "," << destination["y"];
+                 move["x"] = xx.str();
+                 move["y"] = yy.str();
+                 move.clear_children("source");
+                 move.clear_children("destination");
+             }
+         }
+     }
+ }
+ 
+ void convert_old_saves_1_03_0_for_BFW1_14(config& cfg)
+ {
+ }
+ 
+ void convert_old_saves_1_05_0_for_BFW1_10(config& cfg)
+ {
+ 	config& snapshot = cfg.child("snapshot");
+ 	config& replay_start = cfg.child("replay_start");
+ 	config& replay = cfg.child("replay");
+ 
+     // Petrify units on Caves of the Basilisk, Sulla’s Ruins, ...
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			for(config& unit: side.child_range("unit"))
+ 			{
+ 				if(config& status = unit.child("status"))
+ 				{
+ 					if(status.has_attribute("stoned"))
+ 					{
+ 						status.remove_attribute("stoned");
+ 						status["petrified"]="yes";
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ 	version_info loaded_version(cfg["version"]);
+ 	if(loaded_version >= version_info("1.5.0"))
+ 	{
+ 		if(config& replay = cfg.child("replay_start"))
+ 		{
+ 			config& era = replay.child("era");
+ 			config& quick_leader_event = era.add_child("event");
+ 			make_quick_leader_1_6_prestart(quick_leader_event);
+ 			config& side_turn_event = era.add_child("event");
+ 			healthy_trait_1_6_side_turn(side_turn_event);
+ 			config& poisoned_event = era.add_child("event");
+ 			healthy_trait_1_6_poisoned(poisoned_event);
+ 			config& turn_refresh_event = era.add_child("event");
+ 			healthy_trait_1_4_turn_refresh(turn_refresh_event);
+ 			config& attack_end_event = era.add_child("event");
+ 			healthy_trait_1_4_attack_end(attack_end_event);
+ 		}
+ 	}
+ 	int max_side_id = 0;
+ 	std::vector<config::attribute_value> recruit_lists;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		cfg["scenario"] = replay["scenario"];
+ 		cfg["next_scenario"] = "";
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			config leader_create;
+ 			leader_create["id"] = side["id"];
+ 			leader_create["name"] = side["name"];
+ 			leader_create["side"] = side["side"];
+ 			leader_create["type"] = append_suffix_to_unit_type(side["type"], cfg);
+ 			leader_create["gender"] = side["gender"];
+ 			// from src/gamestatus.cpp, handle_leader()
+ 			leader_create["canrecruit"] = "yes";
+ 			leader_create["placement"] = "map,leader";
+ 
+ 			unit_ptr leader = make_unit_ptr(leader_create /*, use_traits=false*/);
+ 			config& leader_config = side.add_child("unit");
+ 			leader->write(leader_config);
+ 
+ 			side["previous_recruits"] = side["recruit"];
+ 			side.remove_attribute("recruit");
+ 		}
+ 		// Uses result from previous loop side["previous_recruits"]
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			int side_id = side["side"].to_int();
+ 			max_side_id = side_id > max_side_id ? side_id : max_side_id;
+ 			recruit_lists.push_back(side["previous_recruits"]);
+ 		}
+ 	}
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		config new_replay;
+ 		config init_command;
+ 		init_command["sent"] = "yes";
+ 		init_command.add_child("init_side");
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			new_replay.add_child("command", command);
+ 			if(command.child("start") || command.child("end_turn"))
+ 			{
+ 				new_replay.add_child("command", init_command);
+ 			}
+ 		}
+ 		cfg.clear_children("replay");
+ 		cfg.add_child("replay", new_replay);
+ 	}
+ 	int active_side_id = 0;
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				active_side_id = active_side_id+1 > max_side_id ? 1 : active_side_id+1;
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+ 				int recruit_list_index = recruit["value"].to_int();
+ 				std::vector<std::string> recruit_list = utils::split(recruit_lists[active_side_id-1], ',');
+ 
+ 				std::sort(recruit_list.begin(), recruit_list.end());
+ 				std::string recruit_type = recruit_list[recruit_list_index];
+ 
+ 				// Need to swap the numbers from generate_traits and generate_name
+ 				// As is, we don't care for keeping the name numbers correct
+ 				int offset = 1;
+ 				if (unit_types.find(recruit_type)->genders().size() < 2) offset = 0;
+ 
+ 				// Offset of 12 numbers for random name and 1 for gender
+ 				int random_number_offset = 12 + 1;
+ 				const int random_calls = command.child_count("random");
+ 				switch (random_calls)
+ 				{
+ 					case 16: // This is 1.4 replays (units have 2 random traits)
+ 					case 15: // This is 1.6 replays (for units with 2 random traits)
+ 						{
+ 						config& first_trait_stored = command.child("random", random_number_offset);
+ 						config& second_trait_stored = command.child("random", random_number_offset+1);
+ 						config& first_trait_new = command.child("random", offset);
+ 						config& second_trait_new = command.child("random", offset+1);
+ 						first_trait_new["value"] = first_trait_stored["value"];
+ 						second_trait_new["value"] = second_trait_stored["value"];
+ 						break;
+ 						}
+ 					case 14: // This is 1.6 replays (for units with 1 random trait: bat, goblin)
+ 						{
+ 						config& first_trait_stored = command.child("random", random_number_offset);
+ 						config& first_trait_new = command.child("random", offset);
+ 						first_trait_new["value"] = first_trait_stored["value"];
+ 						break;
+ 						}
+ 				}
+ 				config& last_stored = command.child("random", random_calls-1);
+ 				// Remove the checksum when we can't get it right
+ 				if (offset == 1) last_stored.clear_children("results");
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void convert_old_saves_1_05_0_for_BFW1_14(config& cfg)
+ {
+ 	int max_side_id = 0;
+ 	std::vector<config::attribute_value> recruit_lists;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		// Uses result from convert_old_saves_1_05_0_for_BFW1_10
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			int side_id = side["side"].to_int();
+ 			max_side_id = side_id > max_side_id ? side_id : max_side_id;
+ 			recruit_lists.push_back(side["previous_recruits"]);
+ 		}
  	}
  
+ 	// Move [era] events to [replay_start]
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		if(config& era = replay.child("era"))
+ 		{
+ 			for(config& era_event: era.child_range("event"))
+ 			{
+ 				if(not era_event.empty()) replay.add_child("event", era_event);
+ 			}
+ 			era.clear_children("event");
+ 		}
+ 	}
+ 
+ 	int active_side_id = 0;
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				active_side_id = active_side_id+1 > max_side_id ? 1 : active_side_id+1;
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+ 				int recruit_list_index = recruit["value"].to_int();
+ 				std::vector<std::string> recruit_list = utils::split(recruit_lists[active_side_id-1], ',');
+ 
+ 				std::sort(recruit_list.begin(), recruit_list.end());
+ 				std::string recruit_type = recruit_list[recruit_list_index];
+ 
+ 				bool gender_choice = true;
+ 				if (unit_types.find(recruit_type)->genders().size() < 2) gender_choice = false;
+ 
+ 				const int random_calls = command.child_count("random");
+ 				switch (random_calls)
+ 				{
+ 					case 16: // This is 1.4 replays (units have 2 random traits)
+ 						{
+ 						command.remove_child("random", random_calls-1);
+ 						if(not gender_choice) command.remove_child("random", random_calls-2);
+ 						break;
+ 						}
+ 					case 15: // This is 1.6 replays (for units with 2 random traits)
+ 						{
+ 						if(not gender_choice) command.remove_child("random", random_calls-1);
+ 						break;
+ 						}
+ 					case 14: // This is 1.6 replays (for units with 1 random trait: bat, goblin)
+ 						{
+ 						if((unit_types.find(recruit_type)->num_traits() == 0) ||
+ 							(unit_types.find(recruit_type)->race()->id() == "undead"))
+ 						{
+ 							// This is 1.4 replays (for units with 0 random trait: wose)
+ 							// This is 1.4 replays (for units with 1 random trait: undead (is a trait))
+ 							command.remove_child("random", random_calls-1);
+ 							command.remove_child("random", random_calls-2);
+ 						} else if(not gender_choice) command.remove_child("random", random_calls-1);
+ 						break;
+ 						}
+ 					case 13: // This is 1.4 replays (for units with 0 random trait: walking corpse)
+ 						{
+ 						command.remove_child("random", random_calls-1);
+ 						break;
+ 						}
+ 				}
+ 			}
+ 		}
+ 	}
+ 	// Remove the random number in attack for unit created from plague
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			if(config& attack = command.child("attack"))
+ 			{
+ 				unsigned int count = 0;
+ 				bool remove_additional_numbers = false;
+ 				for(config& random: command.child_range("random"))
+ 				{
+ 					++count;
+ 					if(config& results = random.child("results"))
+ 					{
+ 						if(results["dies"] == "yes")
+ 						{
+ 							remove_additional_numbers = true;
+ 							break;
+ 						}
+ 					}
+ 					//if(remove_additional_numbers) command.remove_child("random", count);
+ 					//else { ++count; }
+ 				}
+ 				if(remove_additional_numbers && count < command.child_count("random")-1)
+ 				{
+ 					for(unsigned int i = command.child_count("random")-1; i >= count; i--)
+ 					{
+ 						command.remove_child("random", i);
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void convert_old_saves_1_07_0_for_BFW1_10(config& cfg)
+ {
+ 	config& snapshot = cfg.child("snapshot");
+ 	config& replay_start = cfg.child("replay_start");
+ 	config& replay = cfg.child("replay");
+ 
+ 	config& enter_hex_event = replay_start.add_child("event");
+ 	feral_trait_1_8_enter_hex(enter_hex_event);
+ 	config& exit_hex_event = replay_start.add_child("event");
+ 	feral_trait_1_8_exit_hex(exit_hex_event);
+ 
+     // Petrify units on Caves of the Basilisk, Sulla’s Ruins, ...
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			for(config& unit: side.child_range("unit"))
+ 			{
+ 				if(config& status = unit.child("status"))
+ 				{
+ 					if(status.has_attribute("petrified"))
+ 					{
+ 						// Sometimes it is "on" and it isn't a valid value.
+ 						status["petrified"]="yes";
+ 						unit["ellipse"]="none";
+ 						unit["zoc"]="no";
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	// Fix Aethermath events for opening border
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& event: replay.child_range("event"))
+ 		{
+ 			for(config& color: event.child_range("colour_adjust"))
+ 			{
+ 				event.add_child("color_adjust", color);
+ 			}
+ 			event.clear_children("colour_adjust");
+ 		}
+ 	}
+ 
+ 	int max_side_id = 0;
+ 	std::vector<config::attribute_value> recruit_lists;
+ 	std::vector<std::pair<int, map_location> > leader_positions;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			int side_id = side["side"].to_int();
+ 			if (side["controller"] != "null") // The statues in CotB, no problem in 1.4-1.6?!
+ 			{
+ 			    max_side_id = side_id > max_side_id ? side_id : max_side_id;
+ 			    recruit_lists.push_back(side["previous_recruits"]);
+ 			}
+ 		}
+ 
+ 		int counter_x = 0, counter_y = 0;
+ 		for (std::string& line : utils::split(replay["map_data"].str(), '\n'))
+ 		{
+ 			if (line.empty() || line.find("usage") == 0 || line.find("border_size") == 0) continue;
+ 			counter_x = 0;
+ 			for (std::string& hex : utils::split(line, ','))
+ 			{
+ 				for (auto it=hex.begin(); it!=hex.end(); it++)
+ 				{
+ 					char** null = 0;
+ 					if (*it == ' ') continue;
+ 					if (int side = strtol(&(*it), null, 10))
+ 					{
+ 						// See map_location::map_location(config): "we want the coordinates as 0-based."
+ 						leader_positions.push_back(std::make_pair(side, map_location(counter_x-1, counter_y-1)));
+ 					}
+ 					break;
+ 				}
+ 				counter_x++;
+ 			}
+ 			counter_y++;
+ 		}
+ 	}
+ 
+ 	int active_side_id = 0;
+ 	map_location leader_pos = map_location();
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				active_side_id = active_side_id+1 > max_side_id ? 1 : active_side_id+1;
+ 				command["sent"] = "";
+ 				init_side["side_number"] = active_side_id;
+ 				for (auto it = leader_positions.begin() ; it != leader_positions.end(); ++it)
+ 				{
+ 					if ((*it).first == active_side_id)
+ 					{
+ 						leader_pos = (*it).second;
+ 						break;
+ 					}
+ 				}
+ 			}
+ 			if(config& move = command.child("move"))
+ 			{
+ 				std::vector<map_location> steps;
+ 				read_locations(move, steps);
+ 
+ 				for (unsigned i=0 ; i<leader_positions.size(); i++)
+ 				{
+ 					if (leader_positions[i].first == active_side_id)
+ 					{
+ 						if (leader_positions[i].second == steps.front())
+ 						{
+ 							std::stringstream ss;
+ 							ss << "Leader recorded move: ";
+ 							for (auto it=steps.begin() ; it!=steps.end(); it++)
+ 							{
+ 								ss << (*it).x << "." << (*it).y << "|";
+ 							}
+ 							DBG_RG << ss.str() << "\n";
+ 							leader_positions[i] = std::make_pair(active_side_id, steps.back());
+ 							leader_pos = leader_positions[i].second;
+ 							break;
+ 						}
+ 					}
+ 				}
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+ 				const int random_calls = command.child_count("random");
+ 				config& last_stored = command.child("random", random_calls-1);
+ 				// Remove the checksum that we can't get right
+ 				last_stored.clear_children("results");
+ 
+ 				config& leader = recruit.add_child("from");
+ 				leader["x"] = leader_pos.x+1;
+ 				leader["y"] = leader_pos.y+1;
+ 				command["value"] = command["value"].to_int();
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void convert_old_saves_1_07_0_for_BFW1_14(config& cfg)
+ {
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		// From data/tools/wmllint
+ 		// While wmllimt set Gg^Emf for flower, it seems BFW1.14 defines Gg^Efm (Gg^Emf shows as mushroom)
+ 		// From Cynsaun Battlefield (default): Ggf^Fet, Ggf^Fp
+ 		// From Arcanclave Citadel (map pack?): Ggf^Fms
+ 		std::string changes[] = {"^Voha;^Voa", "^Voh;^Vo", "^Vhms;^Vhha", "^Vhm;^Vhh", "^Vcha;^Vca", "^Vch;^Vc", "^Vcm;^Vc", "Ggf^Fms;Gg^Fms", "Ggf^Fet;Gg^Fet", "Ggf^Fp;Gg^Fms", "Ggf^Uf;Gs^Uf", "Ggf;Gg^Efm",  "Qv;Mv"};
+ 		std::ostringstream ss;
+ 		std::size_t found;
+ 		ss << "border_size=1\nusage=map\n\n";
+  		for (std::string& line : utils::split(replay["map_data"].str(), '\n'))
+  		{
+ 			if (line.empty() || line.find("usage") == 0 || line.find("border_size") == 0)
+ 			{
+ 				//ss << line << "\n";
+ 				continue;
+ 			} else {
+ 				std::string oldmap, newmap;
+ 				for(auto it=std::begin(changes); it!=std::end(changes); ++it)
+ 				{
+ 					int sep = (*it).find(";");
+ 					oldmap = (*it).substr(0, sep);
+ 					newmap = (*it).substr(sep+1);
+ 					std::size_t begin = 0;
+ 					found = line.find(oldmap, begin);
+ 					while(found != std::string::npos)
+ 					{
+ 						line.replace(found, oldmap.length(), newmap);
+ 						begin = found+newmap.length();
+ 						found = line.find(oldmap, begin);
+ 					}
+ 				}
+ 				ss << line << "\n";
+ 			}
+ 		}
+ 		replay["map_data"] = ss.str();
+ 
+ 		for(config& side: replay.child_range("side"))
+ 		{
+ 			if(side.has_attribute("colour")) side["color"] = side["colour"];
+ 		}
+ 	}
+ 
+ 	{
+ 	// We need to find all quick 1.8 [29,30]hp units to give them 1 additional hitpoint
+ 	int max_side_id = 0;
+ 	std::vector<config::attribute_value> recruit_lists;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 	    config& add_one_hitpoint_event = replay.add_child("event");
+ 	    rounding_trait_1_8_add_one_hitpoint(add_one_hitpoint_event);
+ 		for(config& side: replay.child_range("side"))
+ 		{
+             int side_id = side["side"].to_int();
+ 
+ 			if(side["controller"] != "null")
+ 			{
+ 				max_side_id = side_id > max_side_id ? side_id : max_side_id;
+ 				recruit_lists.push_back(side["previous_recruits"]);
+ 			}
+ 		}
+ 	}
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		config new_replay;
+ 		int active_side_id = 0;
+ 		if(config& log = replay.child("upload_log"))
+ 		{
+ 			new_replay["upload_log"] = replay["upload_log"];
+ 		}
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				active_side_id = active_side_id+1 > max_side_id ? 1 : active_side_id+1;
+ 			}
+ 			config fire_event;
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+             	int recruit_list_index = recruit["value"].to_int();
+ 				std::vector<std::string> recruit_list = utils::split(recruit_lists[active_side_id-1], ',');
+ 				std::sort(recruit_list.begin(), recruit_list.end());
+ 				std::string this_recruit = recruit_list[recruit_list_index];
+ 				int matching_traits = 0;
+ 				if (!this_recruit.compare(/*pos=*/ 0, /*len=*/ 7, "Footpad") ||
+ 					!this_recruit.compare(/*pos=*/ 0, /*len=*/ 13, "Merman Hunter"))
+ 				{
+ 					int first_trait_pool = 4;
+ 					int second_trait_pool = first_trait_pool-1;
+ 					// Default traits are defined as: {TRAIT_STRONG, TRAIT_QUICK, TRAIT_INTELLIGENT, TRAIT_RESILIENT}
+ 					int quick_first_trait = 1; // looking in a set of 4
+ 					int intelligent_first_trait = 2; // looking in a set of 4
+ 					int quick_second_trait = 1; // looking in a set of 3
+ 					int random_number_offset = 1; // Footpad has 2 genders, so one random number for gender
+ 					if (!this_recruit.compare(/*pos=*/ 0, /*len=*/ 13, "Merman Hunter")) random_number_offset = 0;
+ 
+ 					config::const_child_itors it_random = command.child_range("random");
+ 					int count = 0;
+ 					for(const config& random: it_random)
+ 					{
+ 						if(count == random_number_offset)
+ 						{
+ 							if((random["value"].to_int() % first_trait_pool) == quick_first_trait)
+ 							{
+ 								matching_traits = 2;
+ 								break;
+ 							} else if((random["value"].to_int() % first_trait_pool) == intelligent_first_trait) {
+ 								++matching_traits;
+ 							}
+ 						}
+ 						if(count == random_number_offset+1 && ((random["value"].to_int() % second_trait_pool) == quick_second_trait))
+ 						{
+ 							++matching_traits;
+ 						}
+ 						++count;
+ 					}
+ 				}
+ 				if (!this_recruit.compare(/*pos=*/ 0, /*len=*/ 13, "Elvish Archer"))
+ 				{
+ 					int first_trait_pool = 5;
+ 					int second_trait_pool = first_trait_pool-1;
+ 					// Default traits are defined as: {TRAIT_STRONG, TRAIT_QUICK, TRAIT_INTELLIGENT, TRAIT_RESILIENT, TRAIT_DEXTROUS}
+ 					int strong_first_trait = 0; // looking in a set of 5
+ 					int quick_second_trait = 0; // looking in a set of 4
+ 					int random_number_offset = 1; // Elvish Archer has 2 genders, so one random number for gender
+ 
+ 					config::const_child_itors it_random = command.child_range("random");
+ 					int count = 0;
+ 					for(const config& random: it_random)
+ 					{
+ 						if(count == random_number_offset && ((random["value"].to_int() % first_trait_pool) == strong_first_trait))
+ 						{
+ 							++matching_traits;
+ 						}
+ 						if(count == random_number_offset+1 && ((random["value"].to_int() % second_trait_pool) == quick_second_trait))
+ 						{
+ 							++matching_traits;
+ 						}
+ 						++count;
+ 					}
+ 				}
+ 				if(matching_traits == 2)
+ 				{
+ 					fire_event["from_side"] = active_side_id;
+ 					config& event = fire_event.add_child("fire_event");
+ 					event["raise"] = "add one hitpoint at recruit";
+ 					config& source = event.add_child("source");
+ 					source["x"] = recruit["x"];
+ 					source["y"] = recruit["y"];
+ 				}
+ 			}
+ 			new_replay.add_child("command", command);
+ 			if(fire_event.has_child("fire_event"))
+ 			{
+ 				new_replay.add_child("command", fire_event);
+ 			}
+ 		}
+ 		cfg.clear_children("replay");
+ 		cfg.add_child("replay", new_replay);
+ 	}
+ 	}
+ }
+ 
+ void convert_old_saves_1_09_0(config& cfg)
+ {
+ 	config& snapshot = cfg.child("snapshot");
+ 	config& replay_start = cfg.child("replay_start");
+ 	config& replay = cfg.child("replay");
  
  	if(!cfg.has_child("carryover_sides") && !cfg.has_child("carryover_sides_start")){
  		config carryover;
  		//copy rng and menu items from toplevel to new carryover_sides
  		carryover["random_seed"] = cfg["random_seed"];
  		carryover["random_calls"] = cfg["random_calls"];
+ 		for(const config& menu_item: cfg.child_range("menu_item")){
  			carryover.add_child("menu_item", menu_item);
  		}
  		carryover["difficulty"] = cfg["difficulty"];
  		//the scenario to be played is always stored as next_scenario in carryover_sides_start
  		carryover["next_scenario"] = cfg["scenario"];
  
  		config carryover_start = carryover;
  
  		//get variables according to old hierarchy and copy them to new carryover_sides
  		if(!snapshot.empty()){
+ 			if(const config& variables = snapshot.child("variables")){
+ 				carryover.add_child("variables", variables);
  				carryover_start.add_child("variables", replay_start.child_or_empty("variables"));
+ 			} else if (const config& variables = cfg.child("variables")){
+ 				carryover.add_child("variables", variables);
+ 				carryover_start.add_child("variables", variables);
  			}
  		} else if (!replay_start.empty()){
  			if(const config& variables = replay_start.child("variables")){
***************
*** 712,734 ****
  		cfg.add_child("carryover_sides_start", carryover_start);
  	}
  
  	//if replay and snapshot are empty we've got a start of scenario save and don't want replay_start either
  	if(replay.empty() && snapshot.empty()){
  		LOG_RG<<"removing replay_start \n";
- 		cfg.clear_children("replay_start");
  	}
  
  	//remove empty replay or snapshot so type of save can be detected more easily
  	if(replay.empty()){
  		LOG_RG<<"removing replay \n";
- 		cfg.clear_children("replay");
  	}
  
  	if(snapshot.empty()){
  		LOG_RG<<"removing snapshot \n";
- 		cfg.clear_children("snapshot");
  	}
  }
  //changes done during 1.13.0-dev
  static void convert_old_saves_1_13_0(config& cfg)
  {
--- 1834,2575 ----
  		cfg.add_child("carryover_sides_start", carryover_start);
  	}
  
+ 	bool null_controller = false;
+ 	int max_side_id = 0;
+ 	int next_unit_id = 1;
+ 	int leader_unit_id = 0;
+ 	int offset_unit_id = 0;
+ 	std::vector<config::attribute_value> recruit_lists;
+ 	map_location leader_pos = map_location();
+ 	std::vector<std::pair<int, map_location> > leader_positions;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		// This fix what seems to be an alias/typo is some 1.10 maps (Ggf^Efm is invalid in BFW1.14)
+ 		std::string changes[] = {"Ggf^Efm;Gs^Uf", "Ggf;Gg^Efm"};
+ 		std::ostringstream ss;
+ 		std::size_t found;
+ 		ss << "border_size=1\nusage=map\n\n";
+  		for (std::string& line : utils::split(replay["map_data"].str(), '\n'))
+  		{
+ 			if (line.empty() || line.find("usage") == 0 || line.find("border_size") == 0)
+ 			{
+ 				//ss << line << "\n";
+ 				continue;
+ 			} else {
+ 				std::string oldmap, newmap;
+ 				for(auto it=std::begin(changes); it!=std::end(changes); ++it)
+ 				{
+ 					int sep = (*it).find(";");
+ 					oldmap = (*it).substr(0, sep);
+ 					newmap = (*it).substr(sep+1);
+ 					std::size_t begin = 0;
+ 					found = line.find(oldmap, begin);
+ 					while(found != std::string::npos)
+ 					{
+ 						line.replace(found, oldmap.length(), newmap);
+ 						begin = found+newmap.length();
+ 						found = line.find(oldmap, begin);
+ 					}
+ 				}
+ 				ss << line << "\n";
+ 			}
+ 		}
+ 		replay["map_data"] = ss.str();
+ 
+ 		replay["random_seed"] = cfg["random_seed"];
+ 		replay["random_calls"] = cfg["random_calls"];
+ 
+ 		int counter_x = 0, counter_y = 0;
+ 		for (std::string& line : utils::split(replay["map_data"].str(), '\n'))
+ 		{
+ 			if (line.empty() || line.find("usage") == 0 || line.find("border_size") == 0) continue;
+ 			counter_x = 0;
+ 			for (std::string& hex : utils::split(line, ','))
+ 			{
+ 				for (auto it=hex.begin(); it!=hex.end(); it++)
+ 				{
+ 					char** null = 0;
+ 					if (*it == ' ') continue;
+ 					if (int side = strtol(&(*it), null, 10))
+ 					{
+ 						// See map_location::map_location(config): "we want the coordinates as 0-based."
+ 						leader_positions.push_back(std::make_pair(side, map_location(counter_x-1, counter_y-1)));
+ 					}
+ 					break;
+ 				}
+ 				counter_x++;
+ 			}
+ 			counter_y++;
+ 		}
+ 
+ 		for(config& side: replay.child_range("side"))
+ 		{
+             int side_id = side["side"].to_int();
+ 
+ 			if(!side.child_or_empty("unit").empty())
+ 			{
+ 				for (auto it = leader_positions.begin() ; it != leader_positions.end(); ++it)
+ 				{
+ 					if ((*it).first == side_id)
+ 					{
+ 						leader_pos = (*it).second;
+ 						break;
+ 					}
+ 				}
+ 				for(config& unit: side.child_range("unit"))
+ 				{
+ 					if(unit.has_attribute("canrecruit") && unit["canrecruit"] == "yes")
+ 					{
+ 						++leader_unit_id;
+ 						if(!unit.has_attribute("x"))
+ 						{
+ 							unit["x"] = leader_pos.x+1;
+ 							unit["y"] = leader_pos.y+1;
+ 						}
+ 					} else {
+ 						++next_unit_id;
+ 					}
+ 				}
+ 			}
+ 
+ 			if(side["controller"] == "null")
+ 			{
+ 				// It is expected to match CotB and SR Yetis
+ 				null_controller = true;
+ 			} else {
+ 				max_side_id = side_id > max_side_id ? side_id : max_side_id;
+ 				recruit_lists.push_back(side["previous_recruits"]);
+ 			}
+ 		}
+ 	}
+ 
+ 	// Analysis of events for pre-recruited units in Hornshark Island
+ 	std::vector<std::string > multiplayer_side_recruits;
+ 	std::pair<int, int> pre_recruited_units;
+ 	unsigned int underlying_units = 0, random_calls = 0;
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		for(config& event: replay.child_range("event"))
+ 		{
+ 			if(event["name"] == "prestart")
+ 			{
+ 				if(config& fire_event = event.child("fire_event"))
+ 				{
+ 					if(fire_event["name"] == "place_units")
+ 					{
+ 						config& set_variables = event.child("set_variables");
+ 
+ 						if(config& values = set_variables.child("value"))
+ 						{
+ 							for(config& multiplayer_side: values.child_range("multiplayer_side"))
+ 							{
+ 								multiplayer_side_recruits.push_back(multiplayer_side["recruit"]);
+ 							}
+ 						}
+ 					}
+ 				}
+ 			} else if(event["name"] == "place_units") {
+ 				for(config& side: replay.child_range("side"))
+ 				{
+ 					if(side["controller"] == "null") continue;
+ 
+ 					std::vector<std::string> recruit_list = utils::split(side["previous_recruits"], ',');
+ 					std::sort(recruit_list.begin(), recruit_list.end());
+ 
+ 					unsigned int found = 0;
+ 					for (auto it = multiplayer_side_recruits.begin() ; it != multiplayer_side_recruits.end(); ++it)
+ 					{
+ 						LOG_RG <<recruit_list[0] << " in  '" <<*it << "'? --> " << (it->find(recruit_list[0], 0) != std::string::npos) <<"\n";
+ 						if (it->find(recruit_list[0], 0) != std::string::npos) break;
+ 						++found;
+ 					}
+ 
+ 					// We use the first switch, assuming side 1 and 2 have same number of pre-recruited units.
+ 					config& switch_ = event.child("switch");
+ 					if(found < switch_.child_count("case"))
+ 					{
+ 						unsigned int count = 0;
+ 						for(config& case_: switch_.child_range("case"))
+ 						{
+ 							if(count < found) { ++count; continue; };
+ 							underlying_units += case_.child_count("unit");
+ 							for(config& unit: case_.child_range("unit"))
+ 							{
+ 								if(unit.has_attribute("id")) continue;
+ 								if(unit_types.find(unit["type"])->race()->id() == "undead") continue;
+ 								//if(unit_types.find(unit["type"])->genders().size() > 1) random_calls += 1;
+ 								random_calls += 12; // Name only
+ 							}
+ 							break;
+ 						}
+ 					} else {
+ 						if(config& else_ = switch_.child("else"))
+ 						{
+ 							underlying_units += else_.child_count("unit");
+ 							for(config& unit: else_.child_range("unit"))
+ 							{
+ 								if(unit.has_attribute("id")) continue;
+ 								if(unit_types.find(unit["type"])->race()->id() == "undead") continue;
+ 								//if(unit_types.find(unit["type"])->genders().size() > 1) random_calls += 1;
+ 								random_calls += 12; // Name only
+ 							}
+ 						}
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ 	pre_recruited_units = std::make_pair(underlying_units, random_calls);
+ 
+ 
+ 	// Don't count leaders in next_unit_id for first side turn 1 (except CotB and SR)
+ 	if (not null_controller && underlying_units == 0) offset_unit_id = leader_unit_id;
+ 	next_unit_id += leader_unit_id + pre_recruited_units.first;
+ 
+ 	// We're always wrong by 1 or 2 on 1.4 saves next_unit_id, so skip it
+ 	version_info loaded_version(cfg["version"]);
+ 	if(loaded_version < version_info("1.7.0")) next_unit_id -= 9999;
+ 
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		config new_replay;
+ 		if(config& log = replay.child("upload_log"))
+ 		{
+ 			new_replay["upload_log"] = replay["upload_log"];
+ 		}
+ 		config::attribute_value side;
+ 		int active_side_id = 0;
+ 		int last_attack_seed = cfg["random_seed"];
+ 		int last_attack_calls = 0;
+ 		int last_attack_guessed_calls = 0;
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			config random_seed;
+ 			if(config& start = command.child("start"))
+ 			{
+ 				start["sent"] = "yes";
+ 				config& checkup = command.add_child("checkup");
+ 				config& result = checkup.add_child("result");
+ 				if(next_unit_id > 0) result["next_unit_id"] = next_unit_id-offset_unit_id;
+ 				else result["next_unit_id"] = "";
+ 				result["random_calls"] = pre_recruited_units.second;
+ 
+ 				if(pre_recruited_units.first > 0)
+ 				{
+ 					random_seed["sent"] = "yes";
+ 					random_seed["dependent"] = "yes";
+ 					random_seed["from_side"] = "server";
+ 					config& rnd_seed = random_seed.add_child("random_seed");
+ 					rnd_seed["new_seed"] = cfg["random_seed"].to_int(42);
+ 				}
+ 			}
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				active_side_id = active_side_id+1 > max_side_id ? 1 : active_side_id+1;
+ 				command["sent"] = "";
+ 				config& checkup = command.add_child("checkup");
+ 				config& result = checkup.add_child("result");
+ 				if(next_unit_id > 0) result["next_unit_id"] = next_unit_id-offset_unit_id;
+ 				else result["next_unit_id"] = "";
+ 				result["random_calls"] = 0;
+ 				init_side["side_number"] = active_side_id;
+ 				offset_unit_id = 0;
+ 			}
+ 			if(config& move = command.child("move"))
+ 			{
+ 				move["skip_sighted"] = "all";
+ 				std::vector<map_location> steps;
+ 				read_locations(move, steps);
+ 
+ 				auto it=steps.back();
+ 				config& checkup = command.add_child("checkup");
+ 				config& result = checkup.add_child("result");
+ 				result["final_hex_x"] = it.x+1;
+ 				result["final_hex_y"] = it.y+1;
+ 				result["stopped_early"] = "no";
+ 				config& random_calls = checkup.add_child("result");
+ 				random_calls["random_calls"] = 0;
+ 			}
+ 			if(config& attack = command.child("attack"))
+ 			{
+ 				config& checkup = command.child("checkup");
+ 				//int result_number = checkup.child_count("result");
+ 				//config& result = checkup.child("result", result_number-1);
+ 				random_seed["sent"] = "yes";
+ 				random_seed["dependent"] = "yes";
+ 				random_seed["from_side"] = "server";
+ 				config& rnd_seed = random_seed.add_child("random_seed");
+ 				if(attack.has_attribute("seed"))
+ 				{
+ 					rnd_seed["new_seed"] = attack["seed"];
+ 					last_attack_seed = attack["seed"];
+ 					last_attack_calls = command.child_count("random");
+ 				} else {
+ 					rnd_seed["current_seed"] = last_attack_seed;
+ 					rnd_seed["random_calls"] = last_attack_calls;
+ 					last_attack_calls += command.child_count("random");
+ 				}
+ 				if(last_attack_calls == 0)
+ 				{
+ 					// Make a guess on random_calls based on units strikes
+ 					// This doesn't take into account the berzerk special or death
+ 					// This is only needed if a recruit is coming next
+ 					int counter = 0;
+ 					for(auto it: unit_types.find(attack["attacker_type"])->attacks())
+ 					{
+ 						if(counter == attack["weapon"].to_int(0))
+ 						{
+ 							last_attack_calls = it.num_attacks();
+ 							break;
+ 						}
+ 						++counter;
+ 					}
+ 					if(attack["defender_weapon"] != -1)
+ 					{
+ 						counter = 0;
+ 						for(auto it: unit_types.find(attack["defender_type"])->attacks())
+ 						{
+ 							if(counter == attack["defender_weapon"].to_int(0))
+ 							{
+ 								last_attack_calls += it.num_attacks();
+ 								break;
+ 							}
+ 							++counter;
+ 						}
+ 						const std::string defender = attack["defender_type"];
+ 					}
+ 				}
+ 
+ 				if(attack.has_attribute("attacker_type"))
+ 				{
+ 					bool resolve_plague = false; // If no use has plague, just skip it
+ 					const unit_type *p_attacker = unit_types.find(attack["attacker_type"]);
+ 					const unit_type *p_defender = unit_types.find(attack["defender_type"]);
+ 					// Attacker has always an attack
+ 					attack_type *p_killing_blow = &p_attacker->attacks()[attack["weapon"].to_int(0)];
+ 					if(p_killing_blow->specials().has_child("plague")) resolve_plague = true;
+ 					if(attack["defender_weapon"].to_int(-1) > -1)
+ 					{
+ 						attack_type counter_blow = p_defender->attacks()[attack["defender_weapon"].to_int()];
+ 						if(counter_blow.specials().has_child("plague")) resolve_plague = true;
+ 					}
+ 
+ 					if(resolve_plague)
+ 					{
+ 						if(command.has_child("random"))
+ 						{
+ 							int counter = 0;
+ 							// Increment the next_unit_id is one unit dies from plague
+ 							for(config& random: command.child_range("random"))
+ 							{
+ 								++counter;
+ 								if(config& results = random.child("results"))
+ 								{
+ 									if(results["dies"].str() != "yes") continue;
+ 									// Assume the attacker kills
+ 									const unit_type *p_dead = p_defender;
+ 									if(attack["defender_weapon"].to_int(-1) > -1)
+ 									{
+ 										// Check that attacker actually kills and update p_killing_blow otherwise
+ 										bool switch_role = false;
+ 										attack_type counter_blow = p_defender->attacks()[attack["defender_weapon"].to_int()];
+ 										if(counter_blow.num_attacks() > 0)
+ 										{
+ 											// (problem here: in results unit_hit is always "defender")
+ 											while(counter > p_killing_blow->num_attacks() + counter_blow.num_attacks())
+ 											{
+ 												// This is a berzerk attack
+ 												counter -= (p_killing_blow->num_attacks() + counter_blow.num_attacks());
+ 											}
+ 											int low_num_attacks = counter_blow.num_attacks();
+ 											if(p_killing_blow->num_attacks() < low_num_attacks) low_num_attacks = p_killing_blow->num_attacks();
+ 											if(counter > 2*low_num_attacks)
+ 											{
+ 												if(p_killing_blow->num_attacks() == low_num_attacks) switch_role = true;
+ 											} else {
+ 												bool first_strike_defender = counter_blow.specials().has_child("firststrike");
+ 												if(first_strike_defender)
+ 												{
+ 													if(counter%2 == 1) switch_role = true;
+ 												} else {
+ 													if(counter%2 == 0) switch_role = true;
+ 												}
+ 											}
+ 										}
+ 										if(switch_role)
+ 										{
+ 											p_dead = p_attacker;
+ 											p_killing_blow = &p_defender->attacks()[attack["defender_weapon"].to_int()];
+ 										}
+ 									}
+ 									// Can't call p_killing_blow->get_special_bool() as it requires display::get_singleton()
+ 									if(p_killing_blow->specials().has_child("plague")
+ 										&& (p_dead->race_id() != "undead")
+ 										&& (p_dead->race_id() != "mechanical"))
+ 									{
+ 										++next_unit_id;
+ 									}
+ 								} else {
+ 									// In 1.8, an arbitrary number of values are allocated, skip unused ones
+ 									break;
+ 								}
+ 							}
+ 						}
+ 					} else {
+ 						// We will never get it right without dies=yes/no information from random
+ 						next_unit_id -= 10000;
+ 					}
+ 				} else {
+ 					next_unit_id -= 10000;
+ 				}
+ 			}
+ 			if(config& choose = command.child("choose"))
+ 			{
+ 				command["sent"] = "yes";
+ 				command["dependent"] = "yes";
+ 				command["from_side"] = active_side_id;
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+             	int recruit_list_index = recruit["value"].to_int();
+ 				const int random_calls = command.child_count("random");
+ 				std::vector<std::string> recruit_list = utils::split(recruit_lists[active_side_id-1], ',');
+ 				std::sort(recruit_list.begin(), recruit_list.end());
+             	config& new_seed = command.child("random", random_calls-1);
+ 				command["sent"] = "";
+ 				random_seed["sent"] = "yes";
+ 				random_seed["dependent"] = "yes";
+ 				random_seed["from_side"] = "server";
+ 				config& rnd_seed = random_seed.add_child("random_seed");
+ 				//config& seed_checkup = random_seed.add_child("checkup");
+ 
+ 				// If no last_attack_seed, we will rely on simulation (no valid seed needed)
+ 				if(last_attack_calls == 0 && last_attack_guessed_calls == 0)
+ 				{
+ 					rnd_seed["new_seed"] = last_attack_seed;
+ 				} else {
+ 					rnd_seed["current_seed"] = last_attack_seed;
+ 					if(last_attack_guessed_calls == 0)
+ 					{
+ 						rnd_seed["random_calls"] = last_attack_calls;
+ 					} else {
+ 						rnd_seed["random_calls"] = last_attack_guessed_calls;
+ 					}
+ 				}
+ 
+ 				recruit.remove_attribute("value");
+ 				recruit["type"] = recruit_list[recruit_list_index];
+ 
+ 				last_attack_calls += command.child_count("random");
+ 				++next_unit_id;
+ 			}
+ 			new_replay.add_child("command", command);
+ 			if(random_seed.has_child("random_seed"))
+ 			{
+ 				new_replay.add_child("command", random_seed);
+ 			}
+ 		}
+ 		cfg.clear_children("replay");
+ 		cfg.add_child("replay", new_replay);
+ 	}
+ 
+ 	// All this is to fix recruit command with leader at (-999,-999)
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		int active_side_id = 0;
+ 		for(config& command: replay.child_range("command"))
+ 		{
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				active_side_id = active_side_id+1 > max_side_id ? 1 : active_side_id+1;
+ 				for (auto it = leader_positions.begin() ; it != leader_positions.end(); ++it)
+ 				{
+ 					if ((*it).first == active_side_id)
+ 					{
+ 						leader_pos = (*it).second;
+ 						break;
+ 					}
+ 				}
+ 			}
+ 			if(config& move = command.child("move"))
+ 			{
+ 				std::vector<map_location> steps;
+ 				read_locations(move, steps);
+ 
+ 				for (unsigned i=0 ; i<leader_positions.size(); i++)
+ 				{
+ 					if (leader_positions[i].first == active_side_id)
+ 					{
+ 						if (leader_positions[i].second == steps.front())
+ 						{
+ 							leader_positions[i] = std::make_pair(active_side_id, steps.back());
+ 							leader_pos = leader_positions[i].second;
+ 							break;
+ 						}
+ 					}
+ 				}
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+ 				config& leader = recruit.child("from");
+ 				if(leader["x"].to_int(-1) == -999)
+ 				{
+ 					leader["x"] = leader_pos.x+1;
+ 					leader["y"] = leader_pos.y+1;
+ 				}
+ 			}
+ 		}
+ 	}
  	//if replay and snapshot are empty we've got a start of scenario save and don't want replay_start either
  	if(replay.empty() && snapshot.empty()){
  		LOG_RG<<"removing replay_start \n";
+ 		cfg.remove_child("replay_start", 0);
  	}
  
  	//remove empty replay or snapshot so type of save can be detected more easily
  	if(replay.empty()){
  		LOG_RG<<"removing replay \n";
+ 		cfg.remove_child("replay", 0);
  	}
  
  	if(snapshot.empty()){
  		LOG_RG<<"removing snapshot \n";
+ 		cfg.remove_child("snapshot", 0);
  	}
  }
+ 
+ //changes done during 1.11.0-dev
+ static void convert_old_saves_1_11_0(config& cfg)
+ {
+ 	config& snapshot = cfg.child("snapshot");
+ 	config& replay_start = cfg.child("replay_start");
+ 	config& replay = cfg.child("replay");
+ 
+ 	for(config& side: replay_start.child_range("side"))
+ 	{
+ 		int side_id = side["side"].to_int();
+ 		std::string color[] = {"red", "blue", "green", "purple", "black", "brown", "orange", "white", "teal"};
+ 
+ 		if(side.has_attribute("color"))
+ 			if(side["color"].to_int(-1) != -1) side["color"] = color[side["color"].to_int()-1];
+ 		else if(not side.has_attribute("colour")) side["color"] = color[side_id-1];
+ 		else
+ 			if(side["colour"].to_int(-1) == -1) side["color"]  = side["colour"];
+ 			else side["color"] = color[side["colour"].to_int()-1];
+ 	}
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		bool skip_next_random_seed_sync = false;
+ 		config copy_replay;
+ 		for(config& command : replay.child_range("command"))
+ 		{
+ 			if(config& random_seed = command.child("random_seed"))
+ 			{
+ 				if(skip_next_random_seed_sync)
+ 				{
+ 					skip_next_random_seed_sync = false;
+ 					continue;
+ 				}
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+ 				skip_next_random_seed_sync = false;
+ 				int random_calls = 0;
+ 				std::string recruited_unit_race = unit_types.find(recruit["type"])->race_id();
+ 				// Check for races wth no name
+ 				if(!recruited_unit_race.compare(/*pos=*/ 0, /*len=*/ 6, "undead")
+ 					|| !recruited_unit_race.compare(/*pos=*/ 0, /*len=*/ 4, "bats"))
+ 				{
+ 					if(config& checkup = command.child("checkup"))
+ 					{
+ 						for(config& result : checkup.child_range("result"))
+ 						{
+ 							if(result.has_attribute("random_calls"))
+ 							{
+ 								result["random_calls"] = std::to_string(result["random_calls"].to_int()-12);
+ 								random_calls = result["random_calls"].to_int();
+ 								break;
+ 							}
+ 						}
+ 					}
+ 					if(command.child_count("random") >= 12)
+ 					{
+ 						random_calls = command.child_count("random");
+ 						for(size_t i=0; i<12; ++i)
+ 						{
+ 							command.remove_child("random", random_calls-i-1);
+ 						}
+ 						random_calls -= 12;
+ 					}
+ 					if (random_calls == 0) skip_next_random_seed_sync = true; // No actual call to RNG, so don't send next random_seed
+ 				}
+ 			}
+ 			if(config& attack = command.child("attack"))
+ 			{
+ 				if(attack.has_attribute("attacker_type"))
+ 				{
+ 					bool resolve_plague = false; // If no use has plague, just skip it
+ 					const unit_type *p_attacker = unit_types.find(attack["attacker_type"]);
+ 					const unit_type *p_defender = unit_types.find(attack["defender_type"]);
+ 					// Attacker has always an attack
+ 					attack_type *p_killing_blow = &p_attacker->attacks()[attack["weapon"].to_int(0)];
+ 					if(p_killing_blow->specials().has_child("plague")) resolve_plague = true;
+ 					if(attack["defender_weapon"].to_int(-1) > -1)
+ 					{
+ 						attack_type counter_blow = p_defender->attacks()[attack["defender_weapon"].to_int()];
+ 						if(counter_blow.specials().has_child("plague")) resolve_plague = true;
+ 					}
+ 
+ 					if(resolve_plague)
+ 					{
+ 						skip_next_random_seed_sync = false;
+ 						if(command.has_child("checkup"))
+ 						{
+ 							config& checkup = command.child("checkup");
+ 							int counter = 0;
+ 							bool plague_kill = false;
+ 							// Remove the 12 for names in case plague on the killing blow
+ 							// FIXME Does not cover the case where the dead unit is on village.
+ 							for(config& result: checkup.child_range("result"))
+ 							{
+ 								if(result.has_attribute("hits")) ++counter;
+ 								if(result.has_attribute("random_calls"))
+ 								{
+ 									if(plague_kill)
+ 									{
+ 										if(result["random_calls"].to_int(0) < 13) break;
+ 										// The problem with village is plague killing ulf on village in 3+ rounds.
+ 										result["random_calls"] = result["random_calls"].to_int()-12;
+ 									}
+ 									break;
+ 								}
+ 								if(result["dies"].str() != "yes") continue;
+ 								// Assume the attacker kills
+ 								const unit_type *p_dead = p_defender;
+ 								if(attack["defender_weapon"].to_int(-1) > -1)
+ 								{
+ 									// Check that attacker actually kills and update p_killing_blow otherwise
+ 									bool switch_role = false;
+ 									attack_type counter_blow = p_defender->attacks()[attack["defender_weapon"].to_int()];
+ 									if(counter_blow.num_attacks() > 0)
+ 									{
+ 										// (problem here: in result unit_hit is always "defender")
+ 										while(counter > p_killing_blow->num_attacks() + counter_blow.num_attacks())
+ 										{
+ 											// This is a berzerk attack
+ 											counter -= (p_killing_blow->num_attacks() + counter_blow.num_attacks());
+ 										}
+ 										int low_num_attacks = counter_blow.num_attacks();
+ 										if(p_killing_blow->num_attacks() < low_num_attacks) low_num_attacks = p_killing_blow->num_attacks();
+ 										if(counter > 2*low_num_attacks)
+ 										{
+ 											if(p_killing_blow->num_attacks() == low_num_attacks) switch_role = true;
+ 										} else {
+ 											bool first_strike_defender = counter_blow.specials().has_child("firststrike");
+ 											if(first_strike_defender)
+ 											{
+ 												if(counter%2 == 1) switch_role = true;
+ 											} else {
+ 												if(counter%2 == 0) switch_role = true;
+ 											}
+ 										}
+ 									}
+ 									if(switch_role)
+ 									{
+ 										p_dead = p_attacker;
+ 										p_killing_blow = &p_defender->attacks()[attack["defender_weapon"].to_int(0)];
+ 									}
+ 								}
+ 								// Can't call p_killing_blow->get_special_bool() as it requires display::get_singleton()
+ 								if(p_killing_blow->specials().has_child("plague")
+ 									&& (p_dead->race_id() != "undead")
+ 									&& (p_dead->race_id() != "mechanical"))
+ 								{
+ 									plague_kill = true;
+ 								}
+ 							}
+ 						}
+ 					}
+ 				}
+ 			}
+ 			copy_replay.add_child("command", command);
+ 		}
+ 		cfg.clear_children("replay");
+ 		cfg.add_child("replay", copy_replay);
+ 	}
+ 	if(!cfg.child_or_empty("replay_start").empty())
+ 	{
+ 		config& edit_replay_start = cfg.child("replay_start");
+ 		edit_replay_start.remove_attribute("playing_team");
+ 		if(edit_replay_start.has_attribute("random_seed"))
+ 		{
+ 			std::stringstream stream;
+ 			stream << std::setfill('0') << std::setw(8) << std::hex << edit_replay_start["random_seed"].to_int();
+ 			edit_replay_start["random_seed"] = stream.str();
+ 		}
+ 		for (config& side : edit_replay_start.child_range("side")) {
+ 			if(side["controller"] == "network")
+ 			{
+ 				side["controller"] = "human";
+ 			}
+ 		}
+ 	}
+ 	if(config& replay = cfg.child("replay"))
+ 	{
+ 		config::attribute_value side;
+ 		for(config& command : replay.child_range("command"))
+ 		{
+ 			if(config& init_side = command.child("init_side"))
+ 			{
+ 				command["sent"] = "yes";
+ 				side = init_side["side_number"];
+ 			}
+ 			if(config& end_turn = command.child("end_turn"))
+ 			{
+ 				command["sent"] = "yes";
+ 				end_turn["next_player_number"] = std::to_string(side.to_int(1)+1);
+ 			}
+ 			if(config& recruit = command.child("recruit"))
+ 			{
+ 				command.clear_children("checkup");
+ 				command["sent"] = "yes";
+ 				command["from_side"] = side;
+ 			}
+ 			if(config& random_seed = command.child("random_seed"))
+ 			{
+ 				std::stringstream stream;
+ 				if(random_seed.has_attribute("current_seed"))
+ 				{
+ 					stream << std::setfill('0') << std::setw(8) << std::hex << random_seed["current_seed"].to_int();
+ 					random_seed["current_seed"] = stream.str();
+ 				} else {
+ 					stream << std::setfill('0') << std::setw(8) << std::hex << random_seed["new_seed"].to_int();
+ 					random_seed["new_seed"] = stream.str();
+ 				}
+ 			}
+ 			if(config& speak = command.child("speak"))
+ 			{
+ 				command["undo"] = "no";
+ 			}
+ 		}
+ 	}
+ 
+ 	// Remove empty events
+ 	if(config& replay = cfg.child("replay_start"))
+ 	{
+ 		config copy_event;
+ 		for(config& event: replay.child_range("event"))
+ 		{
+ 			if(not event.empty()) copy_event.add_child("event", event);
+ 		}
+ 		replay.clear_children("event");
+ 		for(config& event: copy_event.child_range("event"))
+ 		{
+ 			replay.add_child("event", event);
+ 		}
+ 	}
+ }
+ 
  //changes done during 1.13.0-dev
  static void convert_old_saves_1_13_0(config& cfg)
  {
***************
*** 793,798 ****
  	{
  		cfg.clear_children("replay_start");
  	}
  	if(config& snapshot = cfg.child("snapshot"))
  	{
  		//make [end_level] -> [end_level_data] since its alo called [end_level_data] in the carryover.
--- 2640,2646 ----
  	{
  		cfg.clear_children("replay_start");
  	}
+ 
  	if(config& snapshot = cfg.child("snapshot"))
  	{
  		//make [end_level] -> [end_level_data] since its alo called [end_level_data] in the carryover.
***************
*** 862,868 ****
  void convert_old_saves(config& cfg)
  {
  	version_info loaded_version(cfg["version"]);
- 	if(loaded_version < version_info("1.12.0"))
  	{
  		convert_old_saves_1_11_0(cfg);
  	}
--- 2710,2737 ----
  void convert_old_saves(config& cfg)
  {
  	version_info loaded_version(cfg["version"]);
+ 	if(loaded_version < version_info("1.5.0"))
+ 	{
+ 		convert_old_saves_1_03_0_for_BFW1_10(cfg);
+ 		convert_old_saves_1_03_0_for_BFW1_14(cfg);
+ 	}
+ 	if(loaded_version < version_info("1.7.0"))
+ 	{
+ 		convert_old_saves_1_05_0_for_BFW1_10(cfg);
+ 		convert_old_saves_1_05_0_for_BFW1_14(cfg);
+ 	}
+ 	if(loaded_version < version_info("1.9.0"))
+ 	{
+ 		convert_old_saves_1_07_0_for_BFW1_10(cfg);
+ 		convert_old_saves_1_07_0_for_BFW1_14(cfg);
+ 	}
+ 	if(loaded_version < version_info("1.11.0"))
+ 	{
+ 		convert_old_saves_1_09_0(cfg);
+ 		// No hope to be able to load-to-continue
+ 		cfg.remove_attribute("snapshot");
+ 	}
+ 	if(loaded_version < version_info("1.13.0"))
  	{
  		convert_old_saves_1_11_0(cfg);
  	}
***************
*** 876,881 ****
  	{
  		convert_old_saves_1_13_1(cfg);
  	}
  	LOG_RG<<"cfg after conversion "<<cfg<<"\n";
  }
  
--- 2745,2768 ----
  	{
  		convert_old_saves_1_13_1(cfg);
  	}
+ 
+ 	if(not convert_version_to_suffix(cfg).empty())
+ 	{
+ 		config& replay = cfg.child("replay");
+ 		config& replay_start = cfg.child("replay_start");
+ 		update_start_unit_types(replay_start, cfg);
+ 		update_replay_unit_types(replay, cfg);
+ 
+ 		update_prestart_detect_factions(cfg);
+ 		update_pre_recruited_loyals(cfg);
+ 	}
+ 	// To initialize {class replay: public rand_rng::rng} with replay version
+ 	// The replay version needs to be passed to rng for RNG backward support
+ 	if (config& replay = cfg.child("replay"))
+ 	{
+ 		replay["version"] = cfg["version"];
+ 	}
+ 
  	LOG_RG<<"cfg after conversion "<<cfg<<"\n";
  }
  
